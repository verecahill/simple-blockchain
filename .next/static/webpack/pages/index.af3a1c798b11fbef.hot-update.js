"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./result/blockchain.js":
/*!******************************!*\
  !*** ./result/blockchain.js ***!
  \******************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\nvar _runtimeJs = _interopRequireDefault(__webpack_require__(/*! ./node_modules/next/dist/compiled/regenerator-runtime/runtime.js */ \"./node_modules/next/dist/compiled/regenerator-runtime/runtime.js\"));\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n        var info = gen[key](arg);\n        var value = info.value;\n    } catch (error) {\n        reject(error);\n        return;\n    }\n    if (info.done) {\n        resolve(value);\n    } else {\n        Promise.resolve(value).then(_next, _throw);\n    }\n}\nfunction _asyncToGenerator(fn) {\n    return function() {\n        var self = this, args = arguments;\n        return new Promise(function(resolve, reject) {\n            var gen = fn.apply(self, args);\n            function _next(value) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n            function _throw(err) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n            _next(undefined);\n        });\n    };\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nvar Block = __webpack_require__(/*! ./block */ \"./result/block.js\");\nvar BN = (__webpack_require__(/*! bn.js */ \"./node_modules/bn.js/lib/bn.js\").BN);\nvar Transaction = __webpack_require__(/*! ./transaction */ \"./result/transaction.js\");\nvar Validation = __webpack_require__(/*! ./validation */ \"./result/validation.js\");\n// 블록체인 설계도\nvar Blockchain = /*#__PURE__*/ function() {\n    \"use strict\";\n    function Blockchain(blockchain) {\n        _classCallCheck(this, Blockchain);\n        // 기존 블록체인이 존재하지 않으면 제네시스 블록을 넣어서 초기화 한다\n        this.blockchain = blockchain || [\n            Block.getGenesis()\n        ];\n        this.mempool = [];\n    }\n    _createClass(Blockchain, [\n        {\n            // 트랜잭션 멤풀에 추가\n            key: \"addTx\",\n            value: function addTx(tx) {\n                this.mempool.push(tx);\n            }\n        },\n        {\n            // 블록을 블록체인에 추가\n            key: \"addBlock\",\n            value: function addBlock(block) {\n                // 유효성 검증\n                var valid = new Validation();\n                var lastBlock = this.blockchain[this.blockchain.length - 1];\n                if (valid.isValidLenght(this.blockchain, block) && valid.isValidBlock(lastBlock, block)) {\n                    this.blockchain.push(block);\n                    console.log(\"\\uCD94\\uAC00\\uB41C \\uBE14\\uB85D\", block);\n                }\n            }\n        },\n        {\n            key: \"slowResolve\",\n            value: function slowResolve() {\n                return new Promise(function(resolve) {\n                    return setTimeout(resolve.bind(), 0);\n                });\n            }\n        },\n        {\n            key: \"mining\",\n            value: // 채굴\n            function mining() {\n                var _this = this;\n                return _asyncToGenerator(_runtimeJs.default.mark(function _callee() {\n                    var transactions, lastBlock, preHash, difficulty, index, newBlock, target, newDifficulty;\n                    return _runtimeJs.default.wrap(function _callee$(_ctx) {\n                        while(1)switch(_ctx.prev = _ctx.next){\n                            case 0:\n                                transactions = _toConsumableArray(_this.mempool);\n                                // 멤풀 초기화\n                                _this.mempool = [];\n                                lastBlock = _this.blockchain[_this.blockchain.length - 1];\n                                preHash = lastBlock.hash;\n                                difficulty = lastBlock.difficulty;\n                                index = lastBlock.index;\n                                newBlock = new Block({\n                                    index: index + 1,\n                                    preHash: preHash,\n                                    timestamp: Date.now(),\n                                    transactions: transactions,\n                                    nonce: 0\n                                });\n                                target = _this.getTarget(difficulty);\n                                // 빠져나가기 위해선 false\n                                while(!(newBlock.getHash() <= target)){\n                                    // nonce를 단조증가 시킨다\n                                    newBlock.nonce++;\n                                }\n                                console.log(target);\n                                // 정답 해시 받기\n                                newBlock.hash = newBlock.getHash();\n                                newDifficulty = _this.getDifficulty(difficulty);\n                                newBlock.difficulty = newDifficulty;\n                                _this.addBlock(newBlock);\n                            case 14:\n                            case \"end\":\n                                return _ctx.stop();\n                        }\n                    }, _callee);\n                }))();\n            }\n        },\n        {\n            // 자가 제한 시스템\n            key: \"getDifficulty\",\n            value: function getDifficulty(difficulty) {\n                var lastBlock = this.blockchain[this.blockchain.length - 1]; // 라스트 블록을 구한다\n                // 라스트 블록이 제네시스 블록이 아닌 블록을 가져오고\n                // 라스트 블록 기준으로 10개씩 나눠서 들어가도록 처리 (10의 배수인값)\n                if (lastBlock.index > 0 && lastBlock.index % 10 == 0) {\n                    console.log(\"\\uB09C\\uC774\\uB3C4 \\uC870\\uC808 \\uC2DC\\uC791\");\n                    // 라스트블록 기준으로 10개 전의 블록의 타임스탬프\n                    var prevTime = this.blockchain[this.blockchain.length - 10].timestamp;\n                    // 라스트블록의 타임스탬프\n                    var lastTime = lastBlock.timestamp;\n                    // (라스트블록 타임스탬프 - 10개전의 블록 타임스탬프) / 개수 / 1000(초로 변경됨)\n                    // 평균 블록 생성 시간\n                    var avgTime = (lastTime - prevTime) / 10 / 1000; // 초\n                    // 평균시간이 20초보다 빠르면 난이도를 올려주고, 20초 보다 느리면 난이도를 낮춰준다\n                    var multiple = avgTime < 20 ? 4 : 1 / 4;\n                    // 난이도를 변경\n                    difficulty = difficulty * multiple;\n                    console.log(\"\\uBCC0\\uACBD\\uB41C \\uB09C\\uC774\\uB3C4\", difficulty);\n                }\n                return difficulty;\n            }\n        },\n        {\n            // 타겟 구하기\n            key: \"getTarget\",\n            value: function getTarget(difficulty) {\n                var HADICAP = 0x4000000;\n                var bits = this.difficultyToBits(difficulty);\n                bits = bits + HADICAP;\n                var bits16 = parseInt(\"0x\" + bits.toString(16), 16);\n                var exponent = bits16 >> 24;\n                var mantissa = bits16 & 0xffffff;\n                var target = mantissa * Math.pow(2, 8 * (exponent - 3));\n                var target16 = target.toString(16);\n                var k = Buffer.from(\"0\".repeat(64 - target16.length) + target16, \"hex\");\n                return k.toString(\"hex\");\n            }\n        },\n        {\n            // 난이도를 통해서 비트구하기\n            key: \"difficultyToBits\",\n            value: function difficultyToBits(difficulty) {\n                var maximumTarget = \"0x00000000ffff\" + \"0\".repeat(64 - 12);\n                var difficulty16 = difficulty.toString(16);\n                var target = parseInt(maximumTarget, 16) / parseInt(difficulty16, 16);\n                var num = new BN(target.toString(16), \"hex\");\n                var compact, nSize, bits;\n                nSize = num.byteLength();\n                if (nSize <= 3) {\n                    compact = num.toNumber();\n                    compact <<= 8 * (3 - nSize);\n                } else {\n                    compact = num.ushrn(8 * (nSize - 3)).toNumber();\n                }\n                if (compact & 0x800000) {\n                    compact >>= 8;\n                    nSize++;\n                }\n                bits = nSize << 24 | compact;\n                if (num.isNeg()) {\n                    bits |= 0x800000;\n                }\n                bits >>>= 0;\n                return parseInt(bits.toString(10));\n            }\n        }\n    ]);\n    return Blockchain;\n}();\n// const bc = new Blockchain();\n// while (true) {\n//   bc.mining();\n// }\nmodule.exports = Blockchain;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXN1bHQvYmxvY2tjaGFpbi5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsSUFBTUEsS0FBSyxHQUFHQyxtQkFBTyxDQUFDLGtDQUFTLENBQUM7QUFDaEMsSUFBTSxFQUFJLEdBQUtBLHVFQUFMO0FBQ1YsSUFBTUUsV0FBVyxHQUFHRixtQkFBTyxDQUFDLDhDQUFlLENBQUM7QUFDNUMsSUFBTUcsVUFBVSxHQUFHSCxtQkFBTyxDQUFDLDRDQUFjLENBQUM7QUFDMUM7QUFDYyxJQUFkLFVBQWdCLGlCQW9JZjs7YUFwSUtJLFVBQVUsQ0FDRkMsVUFBVTs7UUFDcEI7UUFDMEQsSUFBdEQsQ0FBQ0EsVUFBVSxHQUFHQSxVQUFVLElBQUk7WUFBQ04sS0FBSyxDQUFDTyxVQUFVLEVBQUU7U0FBQyxDQUFDO1FBQ3JELElBQUksQ0FBQ0MsT0FBTyxHQUFHLEVBQUUsQ0FBQzs7OztZQUdwQjtZQUNrQkMsR0FBYixFQUFMQSxPQUFLO21CQUFMQSxTQUFBQSxLQUFLLENBQUNDLEVBQUUsRUFBRTtnQkFDUixJQUFJLENBQUNGLE9BQU8sQ0FBQ0csSUFBSSxDQUFDRCxFQUFFLENBQUMsQ0FBQzthQUN2Qjs7O1lBRUQ7WUFDb0JFLEdBQVosRUFBUkEsVUFBUTttQkFBUkEsU0FBQUEsUUFBUSxDQUFDQyxLQUFLLEVBQUU7Z0JBQ2Q7Z0JBQ1UsSUFBSkMsS0FBSyxHQUFHLElBQUlWLFVBQVUsRUFBRTtnQkFDOUIsSUFBTVcsU0FBUyxHQUFHLElBQUksQ0FBQ1QsVUFBVSxDQUFDLElBQUksQ0FBQ0EsVUFBVSxDQUFDVSxNQUFNLEdBQUcsQ0FBQyxDQUFDO2dCQUM3RCxJQUNFRixLQUFLLENBQUNHLGFBQWEsQ0FBQyxJQUFJLENBQUNYLFVBQVUsRUFBRU8sS0FBSyxDQUFDLElBQzNDQyxLQUFLLENBQUNJLFlBQVksQ0FBQ0gsU0FBUyxFQUFFRixLQUFLLENBQUMsRUFDcEM7b0JBQ0EsSUFBSSxDQUFDUCxVQUFVLENBQUNLLElBQUksQ0FBQ0UsS0FBSyxDQUFDLENBQUM7b0JBQzVCTSxPQUFPLENBQUNDLEdBQUcsQ0FBQyxpQ0FBUSxFQUFZUCxLQUFLLENBQUMsQ0FBQztpQkFDOUI7YUFDWjs7O1lBRURRLEdBQVcsRUFBWEEsYUFBVzttQkFBWEEsU0FBQUEsV0FBVyxHQUFHO2dCQUNaLE9BQU8sSUFBSUMsT0FBTyxDQUFDLFNBQUNDLE9BQU87MkJBQUtDLFVBQVUsQ0FBQ0QsT0FBTyxDQUFDRSxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUM7aUJBQUEsQ0FBQyxDQUFDO2FBQ2hFOzs7WUFHS0MsR0FBTSxFQUFOQSxRQUFNO21CQUFaO1lBQUEsU0FBTUEsTUFBTTs7dUJBQVosNkRBQWU7d0JBRVBDLFlBQVksRUFJWlosU0FBUyxFQUVUYSxPQUFPLEVBRVBDLFVBQVUsRUFFVkMsS0FBSyxFQUVMQyxRQUFRLEVBUVJDLE1BQU0sRUFVTkMsYUFBYTs7OztnQ0E5QmJOLFlBQVksR0FBSSxtQkFBRyxNQUFLbkIsT0FBTyxDQUFaLENBQWM7Z0NBQ3ZDO2dDQUNBLE1BQUtBLE9BQU8sR0FBRyxFQUFFLENBQUM7Z0NBRVpPLFNBQVMsR0FBRyxNQUFLVCxVQUFVLENBQUMsTUFBS0EsVUFBVSxDQUFDVSxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUM7Z0NBRXhEWSxPQUFPLEdBQUdiLFNBQVMsQ0FBQ21CLElBQUksQ0FBQztnQ0FFekJMLFVBQVUsR0FBR2QsU0FBUyxDQUFDYyxVQUFVLENBQUM7Z0NBRWxDQyxLQUFLLEdBQUdmLFNBQVMsQ0FBQ2UsS0FBSyxDQUFDO2dDQUV4QkMsUUFBUSxHQUFHLElBQUkvQixLQUFLLENBQUM7b0NBQ3pCOEIsS0FBSyxFQUFFQSxLQUFLLEdBQUcsQ0FBQztvQ0FDaEJGLE9BQU8sRUFBRUEsT0FBTztvQ0FDaEJPLFNBQVMsRUFBRUMsSUFBSSxDQUFDQyxHQUFHLEVBQUU7b0NBQ3JCVixZQUFZLEVBQUVBLFlBQVk7b0NBQzFCVyxLQUFLLEVBQUUsQ0FBQztpQ0FDVCxDQUFDLENBQUM7Z0NBRUdOLE1BQU0sR0FBRyxNQUFLTyxTQUFTLENBQUNWLFVBQVUsQ0FBQyxDQUFDO2dDQUMxQztnQ0FDQSxNQUFPLENBQUMsQ0FBQ0UsUUFBUSxDQUFDUyxPQUFPLEVBQUUsSUFBSVIsTUFBTSxDQUFDLENBQUU7b0NBQ3RDO29DQUNBRCxRQUFRLENBQUNPLEtBQUssRUFBRSxDQUFDO2lDQUNsQjtnQ0FDRG5CLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDWSxNQUFNLENBQUMsQ0FBQztnQ0FDcEI7Z0NBQ0FELFFBQVEsQ0FBQ0csSUFBSSxHQUFHSCxRQUFRLENBQUNTLE9BQU8sRUFBRSxDQUFDO2dDQUU3QlAsYUFBYSxHQUFHLE1BQUtRLGFBQWEsQ0FBQ1osVUFBVSxDQUFDLENBQUM7Z0NBQ3JERSxRQUFRLENBQUNGLFVBQVUsR0FBR0ksYUFBYSxDQUFDO2dDQUNwQyxNQUFLckIsUUFBUSxDQUFDbUIsUUFBUSxDQUFDLENBQUM7Ozs7OztpQkFDekI7YUFBQTs7O1lBRUQ7WUFDY1UsR0FBRCxFQUFiQSxlQUFhO21CQUFiQSxTQUFBQSxhQUFhLENBQUNaLFVBQVUsRUFBRTtnQkFDeEIsSUFBTWQsU0FBUyxHQUFHLElBQUksQ0FBQ1QsVUFBVSxDQUFDLElBQUksQ0FBQ0EsVUFBVSxDQUFDVSxNQUFNLEdBQUcsQ0FBQyxDQUFDLEVBQUU7Z0JBQzdDO2dCQUMwQjtnQkFDUSxJQUFoREQsU0FBUyxDQUFDZSxLQUFLLEdBQUcsQ0FBQyxJQUFJZixTQUFTLENBQUNlLEtBQUssR0FBRyxFQUFFLElBQUksQ0FBQyxFQUFFO29CQUNwRFgsT0FBTyxDQUFDQyxHQUFHLENBQUMsOENBQVcsQ0FBZSxDQUFDO29CQUN6QjtvQkFDMEIsSUFBcENzQixRQUFRLEdBQUcsSUFBSSxDQUFDcEMsVUFBVSxDQUFDLElBQUksQ0FBQ0EsVUFBVSxDQUFDVSxNQUFNLEdBQUcsRUFBRSxDQUFDLENBQUNtQixTQUFTO29CQUNyRTtvQkFDc0IsSUFBbEJRLFFBQVEsR0FBRzVCLFNBQVMsQ0FBQ29CLFNBQVM7b0JBQ2xDO29CQUNzRDtvQkFDdEMsSUFBWlMsT0FBTyxHQUFHLENBQUNELFFBQVEsR0FBR0QsUUFBUSxDQUFDLEdBQUcsRUFBRSxHQUFHLElBQUksRUFBRTtvQkFDL0M7b0JBQ2dFLElBQTlERyxRQUFRLEdBQUdELE9BQU8sR0FBRyxFQUFFLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDO29CQUN2QztvQkFDWWYsVUFBRixHQUFHQSxVQUFVLEdBQUdnQixRQUFRLENBQUM7b0JBQ25DMUIsT0FBTyxDQUFDQyxHQUFHLENBQUMsdUNBQVMsRUFBY1MsVUFBVSxDQUFDLENBQUM7aUJBQ3BDO2dCQUNiLE9BQU9BLFVBQVUsQ0FBQzthQUNuQjs7O1lBRUQ7WUFDVVUsR0FBRCxFQUFUQSxXQUFTO21CQUFUQSxTQUFBQSxTQUFTLENBQUNWLFVBQVUsRUFBRTtnQkFDcEIsSUFBTWlCLE9BQU8sR0FBRyxTQUFTO2dCQUN6QixJQUFJQyxJQUFJLEdBQUcsSUFBSSxDQUFDQyxnQkFBZ0IsQ0FBQ25CLFVBQVUsQ0FBQztnQkFDNUNrQixJQUFJLEdBQUdBLElBQUksR0FBR0QsT0FBTyxDQUFDO2dCQUN0QixJQUFJRyxNQUFNLEdBQUdDLFFBQVEsQ0FBQyxJQUFJLEdBQUdILElBQUksQ0FBQ0ksUUFBUSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQztnQkFDbkQsSUFBSUMsUUFBUSxHQUFHSCxNQUFNLElBQUksRUFBRTtnQkFDM0IsSUFBSUksUUFBUSxHQUFHSixNQUFNLEdBQUcsUUFBUTtnQkFDaEMsSUFBSWpCLE1BQU0sR0FBR3FCLFFBQVEsR0FBRyxJQUF5QixDQUF6QixHQUF5QixDQUF6QixDQUFDLEVBQUssQ0FBQyxHQUFHLENBQUNELFFBQVEsR0FBRyxDQUFDLENBQUMsQ0FBQztnQkFDakQsSUFBSUUsUUFBUSxHQUFHdEIsTUFBTSxDQUFDbUIsUUFBUSxDQUFDLEVBQUUsQ0FBQztnQkFDbEMsSUFBSUksQ0FBQyxHQUFHQyxNQUFNLENBQUNDLElBQUksQ0FBQyxHQUFHLENBQUNDLE1BQU0sQ0FBQyxFQUFFLEdBQUdKLFFBQVEsQ0FBQ3RDLE1BQU0sQ0FBQyxHQUFHc0MsUUFBUSxFQUFFLEtBQUssQ0FBQztnQkFDdkUsT0FBT0MsQ0FBQyxDQUFDSixRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7YUFDMUI7OztZQUVEO1lBQ0FILEdBQWdCLEVBQWhCQSxrQkFBZ0I7bUJBQWhCQSxTQUFBQSxnQkFBZ0IsQ0FBQ25CLFVBQVUsRUFBRTtnQkFDM0IsSUFBTThCLGFBQWEsR0FBRyxnQkFBZ0IsR0FBRyxHQUFHLENBQUNELE1BQU0sQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDO2dCQUM1RCxJQUFNRSxZQUFZLEdBQUcvQixVQUFVLENBQUNzQixRQUFRLENBQUMsRUFBRSxDQUFDO2dCQUM1QyxJQUFJbkIsTUFBTSxHQUFHa0IsUUFBUSxDQUFDUyxhQUFhLEVBQUUsRUFBRSxDQUFDLEdBQUdULFFBQVEsQ0FBQ1UsWUFBWSxFQUFFLEVBQUUsQ0FBQztnQkFDckUsSUFBSUMsR0FBRyxHQUFHLElBQUkzRCxFQUFFLENBQUM4QixNQUFNLENBQUNtQixRQUFRLENBQUMsRUFBRSxDQUFDLEVBQUUsS0FBSyxDQUFDO2dCQUM1QyxJQUFJVyxPQUFPLEVBQUVDLEtBQUssRUFBRWhCLElBQUk7Z0JBQ3hCZ0IsS0FBSyxHQUFHRixHQUFHLENBQUNHLFVBQVUsRUFBRSxDQUFDO2dCQUN6QixJQUFJRCxLQUFLLElBQUksQ0FBQyxFQUFFO29CQUNkRCxPQUFPLEdBQUdELEdBQUcsQ0FBQ0ksUUFBUSxFQUFFLENBQUM7b0JBQ3pCSCxPQUFPLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHQyxLQUFLLENBQUMsQ0FBQztpQkFDN0IsTUFBTTtvQkFDTEQsT0FBTyxHQUFHRCxHQUFHLENBQUNLLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQ0gsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUNFLFFBQVEsRUFBRSxDQUFDO2lCQUNqRDtnQkFDRCxJQUFJSCxPQUFPLEdBQUcsUUFBUSxFQUFFO29CQUN0QkEsT0FBTyxLQUFLLENBQUMsQ0FBQztvQkFDZEMsS0FBSyxFQUFFLENBQUM7aUJBQ1Q7Z0JBQ0RoQixJQUFJLEdBQUcsS0FBTSxJQUFJLEVBQUUsR0FBSWUsT0FBTyxDQUFDO2dCQUMvQixJQUFJRCxHQUFHLENBQUNNLEtBQUssRUFBRSxFQUFFO29CQUNmcEIsSUFBSSxJQUFJLFFBQVEsQ0FBQztpQkFDbEI7Z0JBQ0RBLElBQUksTUFBTSxDQUFDLENBQUM7Z0JBQ1osT0FBT0csUUFBUSxDQUFDSCxJQUFJLENBQUNJLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO2FBQ3BDOzs7O0NBQ0Y7QUFFRCwrQkFBK0I7QUFDL0IsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQixJQUFJO0FBRUppQixNQUFNLENBQUNDLE9BQU8sR0FBR2hFLFVBQVUsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9yZXN1bHQvYmxvY2tjaGFpbi5qcz9mMDY2Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IEJsb2NrID0gcmVxdWlyZShcIi4vYmxvY2tcIik7XHJcbmNvbnN0IHsgQk4gfSA9IHJlcXVpcmUoXCJibi5qc1wiKTtcclxuY29uc3QgVHJhbnNhY3Rpb24gPSByZXF1aXJlKFwiLi90cmFuc2FjdGlvblwiKTtcclxuY29uc3QgVmFsaWRhdGlvbiA9IHJlcXVpcmUoXCIuL3ZhbGlkYXRpb25cIik7XHJcbi8vIOu4lOuhneyytOyduCDshKTqs4Trj4RcclxuY2xhc3MgQmxvY2tjaGFpbiB7XHJcbiAgY29uc3RydWN0b3IoYmxvY2tjaGFpbikge1xyXG4gICAgLy8g6riw7KG0IOu4lOuhneyytOyduOydtCDsobTsnqztlZjsp4Ag7JWK7Jy866m0IOygnOuEpOyLnOyKpCDruJTroZ3snYQg64Sj7Ja07IScIOy0iOq4sO2ZlCDtlZzri6RcclxuICAgIHRoaXMuYmxvY2tjaGFpbiA9IGJsb2NrY2hhaW4gfHwgW0Jsb2NrLmdldEdlbmVzaXMoKV07XHJcbiAgICB0aGlzLm1lbXBvb2wgPSBbXTtcclxuICB9XHJcblxyXG4gIC8vIO2KuOuenOyereyFmCDrqaTtkoDsl5Ag7LaU6rCAXHJcbiAgYWRkVHgodHgpIHtcclxuICAgIHRoaXMubWVtcG9vbC5wdXNoKHR4KTtcclxuICB9XHJcblxyXG4gIC8vIOu4lOuhneydhCDruJTroZ3ssrTsnbjsl5Ag7LaU6rCAXHJcbiAgYWRkQmxvY2soYmxvY2spIHtcclxuICAgIC8vIOycoO2aqOyEsSDqsoDspp1cclxuICAgIGNvbnN0IHZhbGlkID0gbmV3IFZhbGlkYXRpb24oKTtcclxuICAgIGNvbnN0IGxhc3RCbG9jayA9IHRoaXMuYmxvY2tjaGFpblt0aGlzLmJsb2NrY2hhaW4ubGVuZ3RoIC0gMV07XHJcbiAgICBpZiAoXHJcbiAgICAgIHZhbGlkLmlzVmFsaWRMZW5naHQodGhpcy5ibG9ja2NoYWluLCBibG9jaykgJiZcclxuICAgICAgdmFsaWQuaXNWYWxpZEJsb2NrKGxhc3RCbG9jaywgYmxvY2spXHJcbiAgICApIHtcclxuICAgICAgdGhpcy5ibG9ja2NoYWluLnB1c2goYmxvY2spO1xyXG4gICAgICBjb25zb2xlLmxvZyhcIuy2lOqwgOuQnCDruJTroZ1cIiwgYmxvY2spO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc2xvd1Jlc29sdmUoKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZS5iaW5kKCksIDApKTtcclxuICB9XHJcblxyXG4gIC8vIOyxhOq1tFxyXG4gIGFzeW5jIG1pbmluZygpIHtcclxuICAgIC8vIOuppO2SgOyXkCDsnojripQg7Yq4656c7J6t7IWY66as7Iqk7Yq465Ok7J2EIOu4lOuhneyXkCDri7TquLAg7JyE7ZW0IOqwgOyguOyYtFxyXG4gICAgY29uc3QgdHJhbnNhY3Rpb25zID0gWy4uLnRoaXMubWVtcG9vbF07XHJcbiAgICAvLyDrqaTtkoAg7LSI6riw7ZmUXHJcbiAgICB0aGlzLm1lbXBvb2wgPSBbXTtcclxuICAgIC8vIOuniOyngOuniSDruJTroZ0g6rCA7KC47Jik6riwXHJcbiAgICBjb25zdCBsYXN0QmxvY2sgPSB0aGlzLmJsb2NrY2hhaW5bdGhpcy5ibG9ja2NoYWluLmxlbmd0aCAtIDFdO1xyXG4gICAgLy8g66eI7KeA66eJIOu4lOuhnSDtlbTsi5zripQg7IOI66GcIOunjOuTpOyWtOyniCDruJTroZ3snZgg7J207KCE7ZW07Iuc7J2064ukXHJcbiAgICBjb25zdCBwcmVIYXNoID0gbGFzdEJsb2NrLmhhc2g7XHJcbiAgICAvLyDrqqntkZzqsJLsnYQg7JyE7ZWcIOuCnOydtOuPhFxyXG4gICAgY29uc3QgZGlmZmljdWx0eSA9IGxhc3RCbG9jay5kaWZmaWN1bHR5O1xyXG4gICAgLy8g67iU66GdIOuEmOuyhFxyXG4gICAgY29uc3QgaW5kZXggPSBsYXN0QmxvY2suaW5kZXg7XHJcbiAgICAvLyDsg4jroZzsmrQg67iU66GdIOunjOuTpOq4sFxyXG4gICAgY29uc3QgbmV3QmxvY2sgPSBuZXcgQmxvY2soe1xyXG4gICAgICBpbmRleDogaW5kZXggKyAxLFxyXG4gICAgICBwcmVIYXNoOiBwcmVIYXNoLFxyXG4gICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXHJcbiAgICAgIHRyYW5zYWN0aW9uczogdHJhbnNhY3Rpb25zLFxyXG4gICAgICBub25jZTogMCxcclxuICAgIH0pO1xyXG4gICAgLy8g7ZW07Iuc6rCS6rO8IOuqqe2RnOqwkuydhCDruYTqtZDtlbTshJwg66qp7ZGc6rCS67O064ukIO2VtOyLnOqwkuydtCDsnpHsnYTqsr3smrAg67iU66Gd7J2EIOyDneyEse2VmOuPhOuhnSDrkJjslrTsnojsnYwhXHJcbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzLmdldFRhcmdldChkaWZmaWN1bHR5KTtcclxuICAgIC8vIOu5oOyguOuCmOqwgOq4sCDsnITtlbTshKAgZmFsc2VcclxuICAgIHdoaWxlICghKG5ld0Jsb2NrLmdldEhhc2goKSA8PSB0YXJnZXQpKSB7XHJcbiAgICAgIC8vIG5vbmNl66W8IOuLqOyhsOymneqwgCDsi5ztgqjri6RcclxuICAgICAgbmV3QmxvY2subm9uY2UrKztcclxuICAgIH1cclxuICAgIGNvbnNvbGUubG9nKHRhcmdldCk7XHJcbiAgICAvLyDsoJXri7Ug7ZW07IucIOuwm+q4sFxyXG4gICAgbmV3QmxvY2suaGFzaCA9IG5ld0Jsb2NrLmdldEhhc2goKTtcclxuICAgIC8vIOuCnOydtOuPhCDsobDsoIjsnbQg7ZWE7JqUXHJcbiAgICBjb25zdCBuZXdEaWZmaWN1bHR5ID0gdGhpcy5nZXREaWZmaWN1bHR5KGRpZmZpY3VsdHkpO1xyXG4gICAgbmV3QmxvY2suZGlmZmljdWx0eSA9IG5ld0RpZmZpY3VsdHk7XHJcbiAgICB0aGlzLmFkZEJsb2NrKG5ld0Jsb2NrKTtcclxuICB9XHJcblxyXG4gIC8vIOyekOqwgCDsoJztlZwg7Iuc7Iqk7YWcXHJcbiAgZ2V0RGlmZmljdWx0eShkaWZmaWN1bHR5KSB7XHJcbiAgICBjb25zdCBsYXN0QmxvY2sgPSB0aGlzLmJsb2NrY2hhaW5bdGhpcy5ibG9ja2NoYWluLmxlbmd0aCAtIDFdOyAvLyDrnbzsiqTtirgg67iU66Gd7J2EIOq1rO2VnOuLpFxyXG4gICAgLy8g65287Iqk7Yq4IOu4lOuhneydtCDsoJzrhKTsi5zsiqQg67iU66Gd7J20IOyVhOuLjCDruJTroZ3snYQg6rCA7KC47Jik6rOgXHJcbiAgICAvLyDrnbzsiqTtirgg67iU66GdIOq4sOykgOycvOuhnCAxMOqwnOyUqSDrgpjriKDshJwg65Ok7Ja06rCA64+E66GdIOyymOumrCAoMTDsnZgg67Cw7IiY7J246rCSKVxyXG4gICAgaWYgKGxhc3RCbG9jay5pbmRleCA+IDAgJiYgbGFzdEJsb2NrLmluZGV4ICUgMTAgPT0gMCkge1xyXG4gICAgICBjb25zb2xlLmxvZyhcIuuCnOydtOuPhCDsobDsoIgg7Iuc7J6RXCIpO1xyXG4gICAgICAvLyDrnbzsiqTtirjruJTroZ0g6riw7KSA7Jy866GcIDEw6rCcIOyghOydmCDruJTroZ3snZgg7YOA7J6E7Iqk7YOs7ZSEXHJcbiAgICAgIGxldCBwcmV2VGltZSA9IHRoaXMuYmxvY2tjaGFpblt0aGlzLmJsb2NrY2hhaW4ubGVuZ3RoIC0gMTBdLnRpbWVzdGFtcDtcclxuICAgICAgLy8g65287Iqk7Yq467iU66Gd7J2YIO2DgOyehOyKpO2DrO2UhFxyXG4gICAgICBsZXQgbGFzdFRpbWUgPSBsYXN0QmxvY2sudGltZXN0YW1wO1xyXG4gICAgICAvLyAo65287Iqk7Yq467iU66GdIO2DgOyehOyKpO2DrO2UhCAtIDEw6rCc7KCE7J2YIOu4lOuhnSDtg4DsnoTsiqTtg6ztlIQpIC8g6rCc7IiYIC8gMTAwMCjstIjroZwg67OA6rK965CoKVxyXG4gICAgICAvLyDtj4nqt6Ag67iU66GdIOyDneyEsSDsi5zqsIRcclxuICAgICAgbGV0IGF2Z1RpbWUgPSAobGFzdFRpbWUgLSBwcmV2VGltZSkgLyAxMCAvIDEwMDA7IC8vIOy0iFxyXG4gICAgICAvLyDtj4nqt6Dsi5zqsITsnbQgMjDstIjrs7Tri6Qg67mg66W066m0IOuCnOydtOuPhOulvCDsmKzroKTso7zqs6AsIDIw7LSIIOuztOuLpCDripDrpqzrqbQg64Kc7J2064+E66W8IOuCruy2sOykgOuLpFxyXG4gICAgICBsZXQgbXVsdGlwbGUgPSBhdmdUaW1lIDwgMjAgPyA0IDogMSAvIDQ7XHJcbiAgICAgIC8vIOuCnOydtOuPhOulvCDrs4Dqsr1cclxuICAgICAgZGlmZmljdWx0eSA9IGRpZmZpY3VsdHkgKiBtdWx0aXBsZTtcclxuICAgICAgY29uc29sZS5sb2coXCLrs4Dqsr3rkJwg64Kc7J2064+EXCIsIGRpZmZpY3VsdHkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRpZmZpY3VsdHk7XHJcbiAgfVxyXG5cclxuICAvLyDtg4Dqsp8g6rWs7ZWY6riwXHJcbiAgZ2V0VGFyZ2V0KGRpZmZpY3VsdHkpIHtcclxuICAgIGNvbnN0IEhBRElDQVAgPSAweDQwMDAwMDA7XHJcbiAgICBsZXQgYml0cyA9IHRoaXMuZGlmZmljdWx0eVRvQml0cyhkaWZmaWN1bHR5KTtcclxuICAgIGJpdHMgPSBiaXRzICsgSEFESUNBUDtcclxuICAgIGxldCBiaXRzMTYgPSBwYXJzZUludChcIjB4XCIgKyBiaXRzLnRvU3RyaW5nKDE2KSwgMTYpO1xyXG4gICAgbGV0IGV4cG9uZW50ID0gYml0czE2ID4+IDI0O1xyXG4gICAgbGV0IG1hbnRpc3NhID0gYml0czE2ICYgMHhmZmZmZmY7XHJcbiAgICBsZXQgdGFyZ2V0ID0gbWFudGlzc2EgKiAyICoqICg4ICogKGV4cG9uZW50IC0gMykpO1xyXG4gICAgbGV0IHRhcmdldDE2ID0gdGFyZ2V0LnRvU3RyaW5nKDE2KTtcclxuICAgIGxldCBrID0gQnVmZmVyLmZyb20oXCIwXCIucmVwZWF0KDY0IC0gdGFyZ2V0MTYubGVuZ3RoKSArIHRhcmdldDE2LCBcImhleFwiKTtcclxuICAgIHJldHVybiBrLnRvU3RyaW5nKFwiaGV4XCIpO1xyXG4gIH1cclxuXHJcbiAgLy8g64Kc7J2064+E66W8IO2Gte2VtOyEnCDruYTtirjqtaztlZjquLBcclxuICBkaWZmaWN1bHR5VG9CaXRzKGRpZmZpY3VsdHkpIHtcclxuICAgIGNvbnN0IG1heGltdW1UYXJnZXQgPSBcIjB4MDAwMDAwMDBmZmZmXCIgKyBcIjBcIi5yZXBlYXQoNjQgLSAxMik7XHJcbiAgICBjb25zdCBkaWZmaWN1bHR5MTYgPSBkaWZmaWN1bHR5LnRvU3RyaW5nKDE2KTtcclxuICAgIGxldCB0YXJnZXQgPSBwYXJzZUludChtYXhpbXVtVGFyZ2V0LCAxNikgLyBwYXJzZUludChkaWZmaWN1bHR5MTYsIDE2KTtcclxuICAgIGxldCBudW0gPSBuZXcgQk4odGFyZ2V0LnRvU3RyaW5nKDE2KSwgXCJoZXhcIik7XHJcbiAgICBsZXQgY29tcGFjdCwgblNpemUsIGJpdHM7XHJcbiAgICBuU2l6ZSA9IG51bS5ieXRlTGVuZ3RoKCk7XHJcbiAgICBpZiAoblNpemUgPD0gMykge1xyXG4gICAgICBjb21wYWN0ID0gbnVtLnRvTnVtYmVyKCk7XHJcbiAgICAgIGNvbXBhY3QgPDw9IDggKiAoMyAtIG5TaXplKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbXBhY3QgPSBudW0udXNocm4oOCAqIChuU2l6ZSAtIDMpKS50b051bWJlcigpO1xyXG4gICAgfVxyXG4gICAgaWYgKGNvbXBhY3QgJiAweDgwMDAwMCkge1xyXG4gICAgICBjb21wYWN0ID4+PSA4O1xyXG4gICAgICBuU2l6ZSsrO1xyXG4gICAgfVxyXG4gICAgYml0cyA9IChuU2l6ZSA8PCAyNCkgfCBjb21wYWN0O1xyXG4gICAgaWYgKG51bS5pc05lZygpKSB7XHJcbiAgICAgIGJpdHMgfD0gMHg4MDAwMDA7XHJcbiAgICB9XHJcbiAgICBiaXRzID4+Pj0gMDtcclxuICAgIHJldHVybiBwYXJzZUludChiaXRzLnRvU3RyaW5nKDEwKSk7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBjb25zdCBiYyA9IG5ldyBCbG9ja2NoYWluKCk7XHJcbi8vIHdoaWxlICh0cnVlKSB7XHJcbi8vICAgYmMubWluaW5nKCk7XHJcbi8vIH1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmxvY2tjaGFpbjtcclxuIl0sIm5hbWVzIjpbIkJsb2NrIiwicmVxdWlyZSIsIkJOIiwiVHJhbnNhY3Rpb24iLCJWYWxpZGF0aW9uIiwiQmxvY2tjaGFpbiIsImJsb2NrY2hhaW4iLCJnZXRHZW5lc2lzIiwibWVtcG9vbCIsImFkZFR4IiwidHgiLCJwdXNoIiwiYWRkQmxvY2siLCJibG9jayIsInZhbGlkIiwibGFzdEJsb2NrIiwibGVuZ3RoIiwiaXNWYWxpZExlbmdodCIsImlzVmFsaWRCbG9jayIsImNvbnNvbGUiLCJsb2ciLCJzbG93UmVzb2x2ZSIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsImJpbmQiLCJtaW5pbmciLCJ0cmFuc2FjdGlvbnMiLCJwcmVIYXNoIiwiZGlmZmljdWx0eSIsImluZGV4IiwibmV3QmxvY2siLCJ0YXJnZXQiLCJuZXdEaWZmaWN1bHR5IiwiaGFzaCIsInRpbWVzdGFtcCIsIkRhdGUiLCJub3ciLCJub25jZSIsImdldFRhcmdldCIsImdldEhhc2giLCJnZXREaWZmaWN1bHR5IiwicHJldlRpbWUiLCJsYXN0VGltZSIsImF2Z1RpbWUiLCJtdWx0aXBsZSIsIkhBRElDQVAiLCJiaXRzIiwiZGlmZmljdWx0eVRvQml0cyIsImJpdHMxNiIsInBhcnNlSW50IiwidG9TdHJpbmciLCJleHBvbmVudCIsIm1hbnRpc3NhIiwidGFyZ2V0MTYiLCJrIiwiQnVmZmVyIiwiZnJvbSIsInJlcGVhdCIsIm1heGltdW1UYXJnZXQiLCJkaWZmaWN1bHR5MTYiLCJudW0iLCJjb21wYWN0IiwiblNpemUiLCJieXRlTGVuZ3RoIiwidG9OdW1iZXIiLCJ1c2hybiIsImlzTmVnIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./result/blockchain.js\n");

/***/ })

});