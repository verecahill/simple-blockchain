"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./result/blockchain.js":
/*!******************************!*\
  !*** ./result/blockchain.js ***!
  \******************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\nvar _runtimeJs = _interopRequireDefault(__webpack_require__(/*! ./node_modules/next/dist/compiled/regenerator-runtime/runtime.js */ \"./node_modules/next/dist/compiled/regenerator-runtime/runtime.js\"));\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n        var info = gen[key](arg);\n        var value = info.value;\n    } catch (error) {\n        reject(error);\n        return;\n    }\n    if (info.done) {\n        resolve(value);\n    } else {\n        Promise.resolve(value).then(_next, _throw);\n    }\n}\nfunction _asyncToGenerator(fn) {\n    return function() {\n        var self = this, args = arguments;\n        return new Promise(function(resolve, reject) {\n            var gen = fn.apply(self, args);\n            function _next(value) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n            function _throw(err) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n            _next(undefined);\n        });\n    };\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nvar Block = __webpack_require__(/*! ./block */ \"./result/block.js\");\nvar BN = (__webpack_require__(/*! bn.js */ \"./node_modules/bn.js/lib/bn.js\").BN);\nvar Transaction = __webpack_require__(/*! ./transaction */ \"./result/transaction.js\");\nvar Validation = __webpack_require__(/*! ./validation */ \"./result/validation.js\");\n// 블록체인 설계도\nvar Blockchain = /*#__PURE__*/ function() {\n    \"use strict\";\n    function Blockchain(blockchain) {\n        _classCallCheck(this, Blockchain);\n        // 기존 블록체인이 존재하지 않으면 제네시스 블록을 넣어서 초기화 한다\n        this.blockchain = blockchain || [\n            Block.getGenesis()\n        ];\n        this.mempool = [];\n    }\n    _createClass(Blockchain, [\n        {\n            // 트랜잭션 멤풀에 추가\n            key: \"addTx\",\n            value: function addTx(tx) {\n                this.mempool.push(tx);\n            }\n        },\n        {\n            // 블록을 블록체인에 추가\n            key: \"addBlock\",\n            value: function addBlock(block) {\n                // 유효성 검증\n                var valid = new Validation();\n                var lastBlock = this.blockchain[this.blockchain.length - 1];\n                if (valid.isValidLenght(this.blockchain, block) && valid.isValidBlock(lastBlock, block)) {\n                    this.blockchain.push(block);\n                    console.log(\"\\uCD94\\uAC00\\uB41C \\uBE14\\uB85D\", block);\n                }\n            }\n        },\n        {\n            key: \"mining\",\n            value: // 채굴\n            function mining() {\n                var _this = this;\n                return _asyncToGenerator(_runtimeJs.default.mark(function _callee() {\n                    var transactions, lastBlock, preHash, difficulty, index, newBlock, target, newDifficulty;\n                    return _runtimeJs.default.wrap(function _callee$(_ctx) {\n                        while(1)switch(_ctx.prev = _ctx.next){\n                            case 0:\n                                transactions = _toConsumableArray(_this.mempool);\n                                // 멤풀 초기화\n                                _this.mempool = [];\n                                lastBlock = _this.blockchain[_this.blockchain.length - 1];\n                                preHash = lastBlock.hash;\n                                difficulty = lastBlock.difficulty;\n                                index = lastBlock.index;\n                                newBlock = new Block({\n                                    index: index + 1,\n                                    preHash: preHash,\n                                    timestamp: Date.now(),\n                                    transactions: transactions,\n                                    nonce: 0\n                                });\n                                target = _this.getTarget(difficulty);\n                                // 빠져나가기 위해선 false\n                                while(!(newBlock.getHash() <= target)){\n                                    // nonce를 단조증가 시킨다\n                                    newBlock.nonce++;\n                                }\n                                console.log(target);\n                                // 정답 해시 받기\n                                newBlock.hash = newBlock.getHash();\n                                newDifficulty = _this.getDifficulty(difficulty);\n                                newBlock.difficulty = newDifficulty;\n                                _this.addBlock(newBlock);\n                            case 14:\n                            case \"end\":\n                                return _ctx.stop();\n                        }\n                    }, _callee);\n                }))();\n            }\n        },\n        {\n            // 자가 제한 시스템\n            key: \"getDifficulty\",\n            value: function getDifficulty(difficulty) {\n                var lastBlock = this.blockchain[this.blockchain.length - 1]; // 라스트 블록을 구한다\n                // 라스트 블록이 제네시스 블록이 아닌 블록을 가져오고\n                // 라스트 블록 기준으로 10개씩 나눠서 들어가도록 처리 (10의 배수인값)\n                if (lastBlock.index > 0 && lastBlock.index % 10 == 0) {\n                    console.log(\"\\uB09C\\uC774\\uB3C4 \\uC870\\uC808 \\uC2DC\\uC791\");\n                    // 라스트블록 기준으로 10개 전의 블록의 타임스탬프\n                    var prevTime = this.blockchain[this.blockchain.length - 10].timestamp;\n                    // 라스트블록의 타임스탬프\n                    var lastTime = lastBlock.timestamp;\n                    // (라스트블록 타임스탬프 - 10개전의 블록 타임스탬프) / 개수 / 1000(초로 변경됨)\n                    // 평균 블록 생성 시간\n                    var avgTime = (lastTime - prevTime) / 10 / 1000; // 초\n                    // 평균시간이 20초보다 빠르면 난이도를 올려주고, 20초 보다 느리면 난이도를 낮춰준다\n                    var multiple = avgTime < 20 ? 4 : 1 / 4;\n                    // 난이도를 변경\n                    difficulty = difficulty * multiple;\n                    console.log(\"\\uBCC0\\uACBD\\uB41C \\uB09C\\uC774\\uB3C4\", difficulty);\n                }\n                return difficulty;\n            }\n        },\n        {\n            // 타겟 구하기\n            key: \"getTarget\",\n            value: function getTarget(difficulty) {\n                var HADICAP = 0x4000000;\n                var bits = this.difficultyToBits(difficulty);\n                bits = bits + HADICAP;\n                var bits16 = parseInt(\"0x\" + bits.toString(16), 16);\n                var exponent = bits16 >> 24;\n                var mantissa = bits16 & 0xffffff;\n                var target = mantissa * Math.pow(2, 8 * (exponent - 3));\n                var target16 = target.toString(16);\n                var k = Buffer.from(\"0\".repeat(64 - target16.length) + target16, \"hex\");\n                return k.toString(\"hex\");\n            }\n        },\n        {\n            // 난이도를 통해서 비트구하기\n            key: \"difficultyToBits\",\n            value: function difficultyToBits(difficulty) {\n                var maximumTarget = \"0x00000000ffff\" + \"0\".repeat(64 - 12);\n                var difficulty16 = difficulty.toString(16);\n                var target = parseInt(maximumTarget, 16) / parseInt(difficulty16, 16);\n                var num = new BN(target.toString(16), \"hex\");\n                var compact, nSize, bits;\n                nSize = num.byteLength();\n                if (nSize <= 3) {\n                    compact = num.toNumber();\n                    compact <<= 8 * (3 - nSize);\n                } else {\n                    compact = num.ushrn(8 * (nSize - 3)).toNumber();\n                }\n                if (compact & 0x800000) {\n                    compact >>= 8;\n                    nSize++;\n                }\n                bits = nSize << 24 | compact;\n                if (num.isNeg()) {\n                    bits |= 0x800000;\n                }\n                bits >>>= 0;\n                return parseInt(bits.toString(10));\n            }\n        }\n    ]);\n    return Blockchain;\n}();\n// const bc = new Blockchain();\n// while (true) {\n//   bc.mining();\n// }\nmodule.exports = Blockchain;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O2dCQUNEQSxJQUFJLE1BQU0sQ0FBQyxDQUFDO2dCQUNaLE9BQU9HLFFBQVEsQ0FBQ0gsSUFBSSxDQUFDSSxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQzthQUNwQzs7OztDQUNGO0FBRUQsK0JBQStCO0FBQy9CLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakIsSUFBSTtBQUVKaUIsTUFBTSxDQUFDQyxPQUFPLEdBQUczRCxVQUFVLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vcmVzdWx0L2Jsb2NrY2hhaW4uanM/ZjA2NiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBCbG9jayA9IHJlcXVpcmUoXCIuL2Jsb2NrXCIpO1xyXG5jb25zdCB7IEJOIH0gPSByZXF1aXJlKFwiYm4uanNcIik7XHJcbmNvbnN0IFRyYW5zYWN0aW9uID0gcmVxdWlyZShcIi4vdHJhbnNhY3Rpb25cIik7XHJcbmNvbnN0IFZhbGlkYXRpb24gPSByZXF1aXJlKFwiLi92YWxpZGF0aW9uXCIpO1xyXG4vLyDruJTroZ3ssrTsnbgg7ISk6rOE64+EXHJcbmNsYXNzIEJsb2NrY2hhaW4ge1xyXG4gIGNvbnN0cnVjdG9yKGJsb2NrY2hhaW4pIHtcclxuICAgIC8vIOq4sOyhtCDruJTroZ3ssrTsnbjsnbQg7KG07J6s7ZWY7KeAIOyViuycvOuptCDsoJzrhKTsi5zsiqQg67iU66Gd7J2EIOuEo+yWtOyEnCDstIjquLDtmZQg7ZWc64ukXHJcbiAgICB0aGlzLmJsb2NrY2hhaW4gPSBibG9ja2NoYWluIHx8IFtCbG9jay5nZXRHZW5lc2lzKCldO1xyXG4gICAgdGhpcy5tZW1wb29sID0gW107XHJcbiAgfVxyXG5cclxuICAvLyDtirjrnpzsnq3shZgg66mk7ZKA7JeQIOy2lOqwgFxyXG4gIGFkZFR4KHR4KSB7XHJcbiAgICB0aGlzLm1lbXBvb2wucHVzaCh0eCk7XHJcbiAgfVxyXG5cclxuICAvLyDruJTroZ3snYQg67iU66Gd7LK07J247JeQIOy2lOqwgFxyXG4gIGFkZEJsb2NrKGJsb2NrKSB7XHJcbiAgICAvLyDsnKDtmqjshLEg6rKA7KadXHJcbiAgICBjb25zdCB2YWxpZCA9IG5ldyBWYWxpZGF0aW9uKCk7XHJcbiAgICBjb25zdCBsYXN0QmxvY2sgPSB0aGlzLmJsb2NrY2hhaW5bdGhpcy5ibG9ja2NoYWluLmxlbmd0aCAtIDFdO1xyXG4gICAgaWYgKFxyXG4gICAgICB2YWxpZC5pc1ZhbGlkTGVuZ2h0KHRoaXMuYmxvY2tjaGFpbiwgYmxvY2spICYmXHJcbiAgICAgIHZhbGlkLmlzVmFsaWRCbG9jayhsYXN0QmxvY2ssIGJsb2NrKVxyXG4gICAgKSB7XHJcbiAgICAgIHRoaXMuYmxvY2tjaGFpbi5wdXNoKGJsb2NrKTtcclxuICAgICAgY29uc29sZS5sb2coXCLstpTqsIDrkJwg67iU66GdXCIsIGJsb2NrKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIOyxhOq1tFxyXG4gIGFzeW5jIG1pbmluZygpIHtcclxuICAgIC8vIOuppO2SgOyXkCDsnojripQg7Yq4656c7J6t7IWY66as7Iqk7Yq465Ok7J2EIOu4lOuhneyXkCDri7TquLAg7JyE7ZW0IOqwgOyguOyYtFxyXG4gICAgY29uc3QgdHJhbnNhY3Rpb25zID0gWy4uLnRoaXMubWVtcG9vbF07XHJcbiAgICAvLyDrqaTtkoAg7LSI6riw7ZmUXHJcbiAgICB0aGlzLm1lbXBvb2wgPSBbXTtcclxuICAgIC8vIOuniOyngOuniSDruJTroZ0g6rCA7KC47Jik6riwXHJcbiAgICBjb25zdCBsYXN0QmxvY2sgPSB0aGlzLmJsb2NrY2hhaW5bdGhpcy5ibG9ja2NoYWluLmxlbmd0aCAtIDFdO1xyXG4gICAgLy8g66eI7KeA66eJIOu4lOuhnSDtlbTsi5zripQg7IOI66GcIOunjOuTpOyWtOyniCDruJTroZ3snZgg7J207KCE7ZW07Iuc7J2064ukXHJcbiAgICBjb25zdCBwcmVIYXNoID0gbGFzdEJsb2NrLmhhc2g7XHJcbiAgICAvLyDrqqntkZzqsJLsnYQg7JyE7ZWcIOuCnOydtOuPhFxyXG4gICAgY29uc3QgZGlmZmljdWx0eSA9IGxhc3RCbG9jay5kaWZmaWN1bHR5O1xyXG4gICAgLy8g67iU66GdIOuEmOuyhFxyXG4gICAgY29uc3QgaW5kZXggPSBsYXN0QmxvY2suaW5kZXg7XHJcbiAgICAvLyDsg4jroZzsmrQg67iU66GdIOunjOuTpOq4sFxyXG4gICAgY29uc3QgbmV3QmxvY2sgPSBuZXcgQmxvY2soe1xyXG4gICAgICBpbmRleDogaW5kZXggKyAxLFxyXG4gICAgICBwcmVIYXNoOiBwcmVIYXNoLFxyXG4gICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXHJcbiAgICAgIHRyYW5zYWN0aW9uczogdHJhbnNhY3Rpb25zLFxyXG4gICAgICBub25jZTogMCxcclxuICAgIH0pO1xyXG4gICAgLy8g7ZW07Iuc6rCS6rO8IOuqqe2RnOqwkuydhCDruYTqtZDtlbTshJwg66qp7ZGc6rCS67O064ukIO2VtOyLnOqwkuydtCDsnpHsnYTqsr3smrAg67iU66Gd7J2EIOyDneyEse2VmOuPhOuhnSDrkJjslrTsnojsnYwhXHJcbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzLmdldFRhcmdldChkaWZmaWN1bHR5KTtcclxuICAgIC8vIOu5oOyguOuCmOqwgOq4sCDsnITtlbTshKAgZmFsc2VcclxuICAgIHdoaWxlICghKG5ld0Jsb2NrLmdldEhhc2goKSA8PSB0YXJnZXQpKSB7XHJcbiAgICAgIC8vIG5vbmNl66W8IOuLqOyhsOymneqwgCDsi5ztgqjri6RcclxuICAgICAgbmV3QmxvY2subm9uY2UrKztcclxuICAgIH1cclxuICAgIGNvbnNvbGUubG9nKHRhcmdldCk7XHJcbiAgICAvLyDsoJXri7Ug7ZW07IucIOuwm+q4sFxyXG4gICAgbmV3QmxvY2suaGFzaCA9IG5ld0Jsb2NrLmdldEhhc2goKTtcclxuICAgIC8vIOuCnOydtOuPhCDsobDsoIjsnbQg7ZWE7JqUXHJcbiAgICBjb25zdCBuZXdEaWZmaWN1bHR5ID0gdGhpcy5nZXREaWZmaWN1bHR5KGRpZmZpY3VsdHkpO1xyXG4gICAgbmV3QmxvY2suZGlmZmljdWx0eSA9IG5ld0RpZmZpY3VsdHk7XHJcbiAgICB0aGlzLmFkZEJsb2NrKG5ld0Jsb2NrKTtcclxuICB9XHJcblxyXG4gIC8vIOyekOqwgCDsoJztlZwg7Iuc7Iqk7YWcXHJcbiAgZ2V0RGlmZmljdWx0eShkaWZmaWN1bHR5KSB7XHJcbiAgICBjb25zdCBsYXN0QmxvY2sgPSB0aGlzLmJsb2NrY2hhaW5bdGhpcy5ibG9ja2NoYWluLmxlbmd0aCAtIDFdOyAvLyDrnbzsiqTtirgg67iU66Gd7J2EIOq1rO2VnOuLpFxyXG4gICAgLy8g65287Iqk7Yq4IOu4lOuhneydtCDsoJzrhKTsi5zsiqQg67iU66Gd7J20IOyVhOuLjCDruJTroZ3snYQg6rCA7KC47Jik6rOgXHJcbiAgICAvLyDrnbzsiqTtirgg67iU66GdIOq4sOykgOycvOuhnCAxMOqwnOyUqSDrgpjriKDshJwg65Ok7Ja06rCA64+E66GdIOyymOumrCAoMTDsnZgg67Cw7IiY7J246rCSKVxyXG4gICAgaWYgKGxhc3RCbG9jay5pbmRleCA+IDAgJiYgbGFzdEJsb2NrLmluZGV4ICUgMTAgPT0gMCkge1xyXG4gICAgICBjb25zb2xlLmxvZyhcIuuCnOydtOuPhCDsobDsoIgg7Iuc7J6RXCIpO1xyXG4gICAgICAvLyDrnbzsiqTtirjruJTroZ0g6riw7KSA7Jy866GcIDEw6rCcIOyghOydmCDruJTroZ3snZgg7YOA7J6E7Iqk7YOs7ZSEXHJcbiAgICAgIGxldCBwcmV2VGltZSA9IHRoaXMuYmxvY2tjaGFpblt0aGlzLmJsb2NrY2hhaW4ubGVuZ3RoIC0gMTBdLnRpbWVzdGFtcDtcclxuICAgICAgLy8g65287Iqk7Yq467iU66Gd7J2YIO2DgOyehOyKpO2DrO2UhFxyXG4gICAgICBsZXQgbGFzdFRpbWUgPSBsYXN0QmxvY2sudGltZXN0YW1wO1xyXG4gICAgICAvLyAo65287Iqk7Yq467iU66GdIO2DgOyehOyKpO2DrO2UhCAtIDEw6rCc7KCE7J2YIOu4lOuhnSDtg4DsnoTsiqTtg6ztlIQpIC8g6rCc7IiYIC8gMTAwMCjstIjroZwg67OA6rK965CoKVxyXG4gICAgICAvLyDtj4nqt6Ag67iU66GdIOyDneyEsSDsi5zqsIRcclxuICAgICAgbGV0IGF2Z1RpbWUgPSAobGFzdFRpbWUgLSBwcmV2VGltZSkgLyAxMCAvIDEwMDA7IC8vIOy0iFxyXG4gICAgICAvLyDtj4nqt6Dsi5zqsITsnbQgMjDstIjrs7Tri6Qg67mg66W066m0IOuCnOydtOuPhOulvCDsmKzroKTso7zqs6AsIDIw7LSIIOuztOuLpCDripDrpqzrqbQg64Kc7J2064+E66W8IOuCruy2sOykgOuLpFxyXG4gICAgICBsZXQgbXVsdGlwbGUgPSBhdmdUaW1lIDwgMjAgPyA0IDogMSAvIDQ7XHJcbiAgICAgIC8vIOuCnOydtOuPhOulvCDrs4Dqsr1cclxuICAgICAgZGlmZmljdWx0eSA9IGRpZmZpY3VsdHkgKiBtdWx0aXBsZTtcclxuICAgICAgY29uc29sZS5sb2coXCLrs4Dqsr3rkJwg64Kc7J2064+EXCIsIGRpZmZpY3VsdHkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRpZmZpY3VsdHk7XHJcbiAgfVxyXG5cclxuICAvLyDtg4Dqsp8g6rWs7ZWY6riwXHJcbiAgZ2V0VGFyZ2V0KGRpZmZpY3VsdHkpIHtcclxuICAgIGNvbnN0IEhBRElDQVAgPSAweDQwMDAwMDA7XHJcbiAgICBsZXQgYml0cyA9IHRoaXMuZGlmZmljdWx0eVRvQml0cyhkaWZmaWN1bHR5KTtcclxuICAgIGJpdHMgPSBiaXRzICsgSEFESUNBUDtcclxuICAgIGxldCBiaXRzMTYgPSBwYXJzZUludChcIjB4XCIgKyBiaXRzLnRvU3RyaW5nKDE2KSwgMTYpO1xyXG4gICAgbGV0IGV4cG9uZW50ID0gYml0czE2ID4+IDI0O1xyXG4gICAgbGV0IG1hbnRpc3NhID0gYml0czE2ICYgMHhmZmZmZmY7XHJcbiAgICBsZXQgdGFyZ2V0ID0gbWFudGlzc2EgKiAyICoqICg4ICogKGV4cG9uZW50IC0gMykpO1xyXG4gICAgbGV0IHRhcmdldDE2ID0gdGFyZ2V0LnRvU3RyaW5nKDE2KTtcclxuICAgIGxldCBrID0gQnVmZmVyLmZyb20oXCIwXCIucmVwZWF0KDY0IC0gdGFyZ2V0MTYubGVuZ3RoKSArIHRhcmdldDE2LCBcImhleFwiKTtcclxuICAgIHJldHVybiBrLnRvU3RyaW5nKFwiaGV4XCIpO1xyXG4gIH1cclxuXHJcbiAgLy8g64Kc7J2064+E66W8IO2Gte2VtOyEnCDruYTtirjqtaztlZjquLBcclxuICBkaWZmaWN1bHR5VG9CaXRzKGRpZmZpY3VsdHkpIHtcclxuICAgIGNvbnN0IG1heGltdW1UYXJnZXQgPSBcIjB4MDAwMDAwMDBmZmZmXCIgKyBcIjBcIi5yZXBlYXQoNjQgLSAxMik7XHJcbiAgICBjb25zdCBkaWZmaWN1bHR5MTYgPSBkaWZmaWN1bHR5LnRvU3RyaW5nKDE2KTtcclxuICAgIGxldCB0YXJnZXQgPSBwYXJzZUludChtYXhpbXVtVGFyZ2V0LCAxNikgLyBwYXJzZUludChkaWZmaWN1bHR5MTYsIDE2KTtcclxuICAgIGxldCBudW0gPSBuZXcgQk4odGFyZ2V0LnRvU3RyaW5nKDE2KSwgXCJoZXhcIik7XHJcbiAgICBsZXQgY29tcGFjdCwgblNpemUsIGJpdHM7XHJcbiAgICBuU2l6ZSA9IG51bS5ieXRlTGVuZ3RoKCk7XHJcbiAgICBpZiAoblNpemUgPD0gMykge1xyXG4gICAgICBjb21wYWN0ID0gbnVtLnRvTnVtYmVyKCk7XHJcbiAgICAgIGNvbXBhY3QgPDw9IDggKiAoMyAtIG5TaXplKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbXBhY3QgPSBudW0udXNocm4oOCAqIChuU2l6ZSAtIDMpKS50b051bWJlcigpO1xyXG4gICAgfVxyXG4gICAgaWYgKGNvbXBhY3QgJiAweDgwMDAwMCkge1xyXG4gICAgICBjb21wYWN0ID4+PSA4O1xyXG4gICAgICBuU2l6ZSsrO1xyXG4gICAgfVxyXG4gICAgYml0cyA9IChuU2l6ZSA8PCAyNCkgfCBjb21wYWN0O1xyXG4gICAgaWYgKG51bS5pc05lZygpKSB7XHJcbiAgICAgIGJpdHMgfD0gMHg4MDAwMDA7XHJcbiAgICB9XHJcbiAgICBiaXRzID4+Pj0gMDtcclxuICAgIHJldHVybiBwYXJzZUludChiaXRzLnRvU3RyaW5nKDEwKSk7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBjb25zdCBiYyA9IG5ldyBCbG9ja2NoYWluKCk7XHJcbi8vIHdoaWxlICh0cnVlKSB7XHJcbi8vICAgYmMubWluaW5nKCk7XHJcbi8vIH1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmxvY2tjaGFpbjtcclxuIl0sIm5hbWVzIjpbIkJsb2NrIiwicmVxdWlyZSIsIkJOIiwiVHJhbnNhY3Rpb24iLCJWYWxpZGF0aW9uIiwiQmxvY2tjaGFpbiIsImJsb2NrY2hhaW4iLCJnZXRHZW5lc2lzIiwibWVtcG9vbCIsImFkZFR4IiwidHgiLCJwdXNoIiwiYWRkQmxvY2siLCJibG9jayIsInZhbGlkIiwibGFzdEJsb2NrIiwibGVuZ3RoIiwiaXNWYWxpZExlbmdodCIsImlzVmFsaWRCbG9jayIsImNvbnNvbGUiLCJsb2ciLCJtaW5pbmciLCJ0cmFuc2FjdGlvbnMiLCJwcmVIYXNoIiwiZGlmZmljdWx0eSIsImluZGV4IiwibmV3QmxvY2siLCJ0YXJnZXQiLCJuZXdEaWZmaWN1bHR5IiwiaGFzaCIsInRpbWVzdGFtcCIsIkRhdGUiLCJub3ciLCJub25jZSIsImdldFRhcmdldCIsImdldEhhc2giLCJnZXREaWZmaWN1bHR5IiwicHJldlRpbWUiLCJsYXN0VGltZSIsImF2Z1RpbWUiLCJtdWx0aXBsZSIsIkhBRElDQVAiLCJiaXRzIiwiZGlmZmljdWx0eVRvQml0cyIsImJpdHMxNiIsInBhcnNlSW50IiwidG9TdHJpbmciLCJleHBvbmVudCIsIm1hbnRpc3NhIiwidGFyZ2V0MTYiLCJrIiwiQnVmZmVyIiwiZnJvbSIsInJlcGVhdCIsIm1heGltdW1UYXJnZXQiLCJkaWZmaWN1bHR5MTYiLCJudW0iLCJjb21wYWN0IiwiblNpemUiLCJieXRlTGVuZ3RoIiwidG9OdW1iZXIiLCJ1c2hybiIsImlzTmVnIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./result/blockchain.js\n");

/***/ })

});